<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../lib/style-properties.html">
<link rel="import" href="../lib/settings.html">
<link rel="import" href="../lib/style-defaults.html">
<link rel="import" href="../lib/style-cache.html">
<link rel="import" href="../lib/style-util.html">
<script>
Polymer.ApplyShim = (function(){
  'use strict';

  var propertyUtils = Polymer.StyleProperties;
  var styleUtil = Polymer.StyleUtil;

  var MIXIN_MATCH = propertyUtils.rx.MIXIN_MATCH;
  var VAR_ASSIGN = propertyUtils.rx.VAR_ASSIGN;

  // map of mixin to property names
  // --foo: {border: 2px} -> (--foo, {border: '2px'})
  var mixinMap = Object.create(null);

  function mapSet(name, prop) {
    var old = mixinMap[name];
    if (old) {
      var reset = diff(old, prop);
      reset.forEach(function(r) {
        prop[r] = 'initial';
      })
    }
    mixinMap[name] = prop;
  }

  // get(--foo) -> '--foo-border: 2px;'
  function mapGet(name) {
    return mixinMap[name];
  }

  function diff(oldProp, newProp) {
    var diff = [];
    Object.keys(oldProp).forEach(function(p) {
      if (!newProp[p]) {
        diff.push(p);
      }
    });
    return diff;
  }

  function flattenMixin(name, props) {
    return Object.keys(props).map(function(p){
      return name + '-' + p + ':' + props[p];
    }).join(';') + ';';
  }

  function applyVars(name, props, defaults) {
    return Object.keys(props).map(function(p){
      var fallback = defaults && defaults[p];
      var parts = [p, ': var(', name, '-', p, ')'];
      if (fallback) {
        parts.splice(parts.length - 1, 0, ',', fallback);
      }
      return parts.join('');
    }).join('; ');
  }

  function textToProps(text) {
    var props = text.split(';');
    var out = {};
    for (var i = 0, p, sp; i < props.length; i++) {
      p = props[i];
      if (p) {
        sp = p.split(':');
        if (sp.length >= 2) {
          out[sp[0].trim()] = sp.slice(1).map(function(n) {
            return n.trim();
          }).join(':');
        }
      }
    }
    return out;
  }

  function assign(all, name, _, mixin) {
    if (!mixin) {
      return all;
    }
    var defaults = collectDefaults(mixin);
    mixin = mixin.replace(MIXIN_MATCH, function(all, name) {
      return apply(all, name, defaults);
    });
    var prefix = all.slice(0, all.indexOf('--'));
    name = name.trim();
    var subprops = textToProps(mixin);
    mapSet(name, subprops);
    return prefix + flattenMixin(name, subprops);
  }

  function apply(all, name, defaults) {
    var prefix = all.slice(0, all.indexOf('@apply'));
    name = name.replace(/;\s*/m, '');
    var mixin = mapGet(name);
    var vars = '';
    if (mixin) {
      vars = applyVars(name, mixin, defaults) + ';';
    }
    return prefix + vars;
  }

  function collectDefaults(cssText) {
    return textToProps(cssText.replace(MIXIN_MATCH,
      function(all) {
        return all.slice(0, all.indexOf('@apply'));
      })
    );
  }

  function fixOrderInShadowDOMInstances(proto) {
    var s = proto._template &&
      proto._template.content.querySelector('style');
    if (s) {
      var selector = proto.extends ? '[is=' + proto.is + ']' : proto.is;
      // TODO(sorvell): won't work in attachShadow
      // could keep an instance map instead of the querySelectorAll.
      var e$ = document.querySelectorAll('html /deep/ ' + selector);
      for (var j=0, e; (j < e$.length) && (e = e$[j]); j++) {
        var c = e.shadowRoot && e.shadowRoot.firstElementChild;
        if (c && c.localName === 'style') {
          c.parentNode.replaceChild(s.cloneNode(true), c);
        }
      }
    }
  }

  // TODO(sorvell): Temporary ordering fixup. This approach can be refined
  // to do less work, or this might be ok if the fast answer is build.
  function fixOrder() {
    // TODO(sorvell): make compatible with lazyRegister
    if (Polymer.StyleUtil.HAS_NATIVE_VARIABLES) {
      // in reverse registration order.
      var r$ = Polymer.telemetry.registrations;
      for (var i=r$.length-1, proto; i>=0; i--) {
        proto = r$[i];
        // TODO(sorvell): abort if the element has not fully registered; need
        // to work out issues with lazyRegister
        if (!proto.__hasRegisterFinished) {
          continue;
        }
        // FIX registrations
        var s = !Polymer.Settings.useNativeShadow ?
            document.head.querySelector('style[scope=' + proto.is + ']') :
            proto._template && proto._template.content.querySelector('style');
        if (s) {
          s.parentNode.removeChild(s);
        }
        // TODO(sorvell): this re-does significant work that could be factored away.
        // re-shim styles...
        proto._prepShimStyles();
        // FIX instances with shadowRoot
        if (Polymer.Settings.useNativeShadow) {
          fixOrderInShadowDOMInstances(proto);
        }
      }
    }
  }

  Polymer.RenderStatus.whenReady(function() {
    if (document.readyState === 'loading') {
      addEventListener('DOMContentLoaded', fixOrder);
    } else {
      fixOrder();
    }
  });

  return {
    transform: function(styles) {
      styleUtil.forRulesInStyles(styles, this.transformRule);
    },
    transformRule: function(rule) {
      var cssText = rule.parsedCssText;
      // produce variables
      cssText = cssText.replace(VAR_ASSIGN, assign);
      var defaults = collectDefaults(cssText);
      // consume mixins
      cssText = cssText.replace(MIXIN_MATCH, function(all, name) {
        return apply(all, name, defaults);
      });
      rule.cssText = cssText;
    }
  };
})();
</script>
